/*

ANSI-SQL > Modeling > PL/SQL

데이터베이스 구축
- 프로젝트 진행 > 다량의 데이터 발생 > 저장하기 위한 조직화된 구조 필요 > 설계 > 구조 생성 > 데이터 생성 + SQL
1. 데이터베이스 모델링
2. 데이터베이스 설계
3. 데이터베이스 구축

1. 데이터베이스 모델링
- 가장 초반에 하는 작업
- 가장 중요한 작업
- 설계도 작업(*****)
- 아이템 선정 > 요구분석 > 데이터베이스 구성을 위한 정보(Raw) 수집 > 분석 > 조직화된 저장 구조 > 도식화(설계도) > ERD(최종 산출물)
- 아직 이 단계에서는 DBMS의 종류는 결정되지 않는다.(특정 DB를 위한 그림X > 모든 DB에 공통적인 그림O)

2. 데이터베이스 설계
- 실제 사용할 DBMS를 결정한다.
- 모델링 결과물(ERD) > 구체화하는 작업
- 객체 식별자 생성, 자료형 지정, 제약 사항 추가 등..
- 데이터베이스 설계의 결과물 > 스크립트(*.sql) + DDL(create, alter, drop)

3. 데이터베이스 구축
- 1~2 결과 토대 > 현실화 > 물리적으로 만드는 작업
- 오라클에 테이블(각종 객체)이 생성되는 작업

4. 데이터 추가
- 더미용 데이터 추가 (프로그램 > 90% 이상)
- 정확한 테스트용 데이터 (수기 작성 > 10% 내외)

5. 업무 SQL 작성 (시간이 오래 걸림)
- 프로그램에 사용될 모든 SQL를 미리 작성
- 이 단계를 진행하는 과정에 1~3까지의 문제점이 발견된다.
- ex) 게시판
    a. 요구 분석, ERD, 테이블 구현, 더미 데이터 작성
    b. 자바 프로그램 작성(자바 + SQL)

    a. 요구 분석, ERD, 테이블 구현, 더미 데이터 작성
    b. SQL 작성
    c. 자바 프로그램 작성(자바)


--------------------------------------------------------------------------------


데이터베이스 모델링
1. ERD, Entity Relation Diagram
    - 엔티티간의 관계를 표현한 그림
    - 데이터베이스 모델링 기법 중에 하나 > 대표적 방법
    - 손, 오피스, 전문툴(exERD, SQL Developer, ER-WIN 등)

2. Entity, 엔티티
    - 다른 Entity와 분류(구분)될 수 있고, 다른 Entity에 대해서 정해진 관계를 맺을 수 있는 데이터 단위
    - 객체(속성의 집합) : 자바의 인스턴스(객체)
    - 테이블
    ex) 회사 관리 프로그램
        a. 사원 정보 관리
            - 정보 : 사원명, 나이, 연락처, 주소, 사원번호 등..
            - (사원명, 나이, 연락처, 주소, 사원번호) > 사원 > 엔티티(=테이블)
        b. 부서 정보 관리
            - 정보 : 부서명, 부서번호, 사무실번호, 내선번호 등..
            - (부서명, 부서번호, 사무실번호, 내선번호) > 부서 > 엔티티(=테이블)

3. Entity Relationship, 엔티티 관계
    - 엔티티간의 관계
    - 테이블과 테이블의 관계

4. Attribute, 속성
    - 엔티티가 가지는 속성(특성, 성질)
    - 엔티티를 만들기 위해서 하나로 모였던 각각의 정보들
    - 컬럼, 자바 클래스의 멤버 변수 역할
    - ex) 사원 엔티티 = 사원명 속성 + 사원번호 속성 + 연락처 속성 + 주소 속성 등..

5. Tuple, 튜플
    - 엔티티에 정의된 규칙에 따라 실제 만들어진 데이터
    - 레코드, 행, 객체
    - ex) 실체화된 속성의 집합 > 테이블 레코드 1줄


ERD에서 Entity, Attribute, Relation 등을 표현하는 방법(그림 그리는 방법)
- (사원명, 나이, 연락처, 주소, 사원번호) > 사원 > 엔티티(=테이블)
- (부서명, 부서번호, 사무실번호, 내선번호) > 부서 > 엔티티(=테이블)

1. Entity
    - 사각형으로 표시
    - 이름을 작성(한글, 영어 등)
    - 엔티티명은 하나의 ERD내에서는 유일
    - 보통 단수로 표기

2. Attribute
    - 엔티티 안에 표기(목록 형태)
    - 파스칼 표기 or 전부 소문자 표기
    - 보통 단수로 표기
    - 추가 표기 사항(속성에 대한 특징 기술)
        a. NN, Not null
            - 해당 속성을 비워둘 수 없다.
            - 필수값

        b. ND, Not duplicate
            - 해당 속성은 중복될 수 없다.
            - 유일값(유니크)

        1. 중복되면 안되고, 생략되면 안된다.(NN, ND)
            - #* 속성명

        2. 생략되면 안된다. (NN)
            - * 속성명

        3. 중복되면 안된다. (ND)
            - # 속성명

        4. 중복되도 되고, 생략되도 된다.
            - 속성명
            - o 속성명
            - optional

3. Relationship
    - 가장 중요하게 작업해야 할 단계
    - 엔티티와 엔티티의 관계 > 레코드와 레코드의 관계 > 부모테이블의 PK와 자식테이블의 FK의 관계 > 컬럼과 컬럼간의 관계
    - 관계의 패턴(종류)
        A엔티티 : B엔티티
        a. 1 : 1
            - 1개의 A는 1개의 B와 관계
        b. 1 : 0
            - 1개의 A는 0개의 B와 관계 //무관계
        c. 1 : N
            - 1개의 A는 1개 이상의 B와 관계
        d. 1 : N
            - 1개의 A는 0개 이상의 B와 관계
        e. N : N -> 파괴 후, 중간 테이블( 1 : N - N : 1 관계로 변경) 추가 후 (a,b,c,d)로 조작
            - 깨졌던 테이블이 부모가 되고 새로운 테이블이 자식 테이블
            - N개의 A는 N개의 B와 관계

키, Key
- 속성, 컬럼
- 역할을 부여한 속성

1. 기본 키, Primary key
- 레코드(행)을 다른 레코드(행)과 구분하는 역할
- 식별자(******)
- NN + ND
- 테이블에는 반드시 기본키가 존재해야 한다.

2. 후보키, Candidate key
- 레코드(행)을 다른 레코드(행)과 구분할 수 있는 키
- 후보키들 중 대표로 선발된 키 -> 기본키

3. 대체키, Alternate key
- 후보키들 중 기본키를 제외한 나머지 키
- 기본키 + 대체키 = 후보키

4. 슈퍼키, Super key
- 복합키, Composite key
- 1개 키만을 가지고 식별자 역할이 불가능 경우 -> 2개 이상의 키를 조합해서 기본키 역할

5. 외래키, Foreign key
- 부모 테이블의 기본 키를 참조하는 키
- ex) genre number not null references tblGenre(seq) : tblVideo 테이블의 genre 컬럼(FK)이 tblGenre 테이블의 seq컬럼(PK)를 참조한다.

6. 일반 키
- 1~5 중 아무것도 해당하지 않는 키

시간 순으로...
1. 먼저 태어나는 엔티티 : 부모
2. 나중에 태어나는 엔티티 : 자식
eXERD 부모를 먼저 잡고 Relationship 연결


ERD 종류
1. 논리 다이어그램, Logical Diagram
    - 업무를 설명하기 위한 ERD > 데이터의 성격 + 관계
    - 모든 식별자 > 한글 정의
    - 목적 : 업무 파악을 위해서

2. 물리 다이어그램, Physical Diagram
    - 논리 다이어그램을 기반으로 실제 데이터베이스 반영하기 위해 구체적인 표현을 추가한 다이어그램
    - 모든 식별자 -> 오라클에 적합하게 만들기(영어로)
    - 자료형 명시
    - 제약사향 명시
    - 목적: 구현하기 위해서


모델링 작업 -> ERD 작성 -> 정규화(기존 ERD의 잘못됐거나 비효율적인 구조를 찾아서 효율적으로 고치는 과정) -> DDL(create)

*/





















